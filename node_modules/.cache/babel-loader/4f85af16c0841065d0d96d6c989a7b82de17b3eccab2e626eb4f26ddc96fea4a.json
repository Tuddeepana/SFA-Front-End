{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport axios from 'axios';\nconst apiClient = axios.create({\n  baseURL: 'http://localhost:8088',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Track if we're already refreshing to prevent infinite loops\nlet isRefreshing = false;\nlet failedQueue = [];\n\n// Process queued requests after refresh\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\n\n// Request interceptor with better token handling\napiClient.interceptors.request.use(config => {\n  const token = localStorage.getItem('token');\n  if (token) {\n    // Format might need adjustment based on your backend requirements\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n}, error => Promise.reject(error));\n\n// Response interceptor to handle token refresh\napiClient.interceptors.response.use(response => response, async error => {\n  const originalRequest = error.config;\n\n  // If error is 403 and we haven't tried refreshing yet\n  if (error.response?.status === 403 && !originalRequest._retry) {\n    if (isRefreshing) {\n      // Queue this request if we're already refreshing\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers.Authorization = `Bearer ${token}`;\n        return apiClient(originalRequest);\n      }).catch(err => Promise.reject(err));\n    }\n    originalRequest._retry = true;\n    isRefreshing = true;\n    try {\n      // Get refresh token\n      const refreshToken = localStorage.getItem('refreshToken');\n      if (!refreshToken) {\n        throw new Error('No refresh token available');\n      }\n\n      // Attempt token refresh - adjust URL as needed\n      const response = await apiClient.post('/api/auth/refresh', {\n        refreshToken: refreshToken\n      });\n      const {\n        token,\n        refreshToken: newRefreshToken\n      } = response.data;\n      localStorage.setItem('token', token);\n      localStorage.setItem('refreshToken', newRefreshToken);\n\n      // Update auth header for original request and queued requests\n      apiClient.defaults.headers.common.Authorization = `Bearer ${token}`;\n      originalRequest.headers.Authorization = `Bearer ${token}`;\n      processQueue(null, token);\n      return apiClient(originalRequest);\n    } catch (refreshError) {\n      processQueue(refreshError, null);\n      // Handle auth failure - redirect to login\n      localStorage.removeItem('token');\n      localStorage.removeItem('refreshToken');\n      window.location = '/login';\n      return Promise.reject(refreshError);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n  return Promise.reject(error);\n});\nexport default {\n  login(email, password) {\n    return apiClient.post('/api/auth/login', {\n      email,\n      password\n    }).then(response => {\n      // Store both tokens for refresh capability\n      const {\n        token,\n        refreshToken\n      } = response.data;\n      localStorage.setItem('token', token);\n      localStorage.setItem('refreshToken', refreshToken);\n      return response;\n    });\n  },\n  logout() {\n    localStorage.removeItem('token');\n    localStorage.removeItem('refreshToken');\n    return Promise.resolve();\n  },\n  getEmployees(page = 0, size = 20) {\n    return apiClient.get(`/api/employees?page=${page}&size=${size}`);\n  }\n};","map":{"version":3,"names":["axios","apiClient","create","baseURL","headers","isRefreshing","failedQueue","processQueue","error","token","forEach","prom","reject","resolve","interceptors","request","use","config","localStorage","getItem","Authorization","Promise","response","originalRequest","status","_retry","push","then","catch","err","refreshToken","Error","post","newRefreshToken","data","setItem","defaults","common","refreshError","removeItem","window","location","login","email","password","logout","getEmployees","page","size","get"],"sources":["D:/Wrenix/Spring-Sfa/Cuba/template/template/src/services/apiService.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst apiClient = axios.create({\r\n  baseURL: 'http://localhost:8088',\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n});\r\n\r\n// Track if we're already refreshing to prevent infinite loops\r\nlet isRefreshing = false;\r\nlet failedQueue = [];\r\n\r\n// Process queued requests after refresh\r\nconst processQueue = (error, token = null) => {\r\n  failedQueue.forEach(prom => {\r\n    if (error) {\r\n      prom.reject(error);\r\n    } else {\r\n      prom.resolve(token);\r\n    }\r\n  });\r\n\r\n  failedQueue = [];\r\n};\r\n\r\n// Request interceptor with better token handling\r\napiClient.interceptors.request.use(\r\n  (config) => {\r\n    const token = localStorage.getItem('token');\r\n    if (token) {\r\n      // Format might need adjustment based on your backend requirements\r\n      config.headers.Authorization = `Bearer ${token}`;\r\n    }\r\n    return config;\r\n  },\r\n  (error) => Promise.reject(error)\r\n);\r\n\r\n// Response interceptor to handle token refresh\r\napiClient.interceptors.response.use(\r\n  (response) => response,\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n\r\n    // If error is 403 and we haven't tried refreshing yet\r\n    if (error.response?.status === 403 && !originalRequest._retry) {\r\n      if (isRefreshing) {\r\n        // Queue this request if we're already refreshing\r\n        return new Promise((resolve, reject) => {\r\n          failedQueue.push({ resolve, reject });\r\n        })\r\n          .then(token => {\r\n            originalRequest.headers.Authorization = `Bearer ${token}`;\r\n            return apiClient(originalRequest);\r\n          })\r\n          .catch(err => Promise.reject(err));\r\n      }\r\n\r\n      originalRequest._retry = true;\r\n      isRefreshing = true;\r\n\r\n      try {\r\n        // Get refresh token\r\n        const refreshToken = localStorage.getItem('refreshToken');\r\n        if (!refreshToken) {\r\n          throw new Error('No refresh token available');\r\n        }\r\n\r\n        // Attempt token refresh - adjust URL as needed\r\n        const response = await apiClient.post('/api/auth/refresh', {\r\n          refreshToken: refreshToken\r\n        });\r\n\r\n        const { token, refreshToken: newRefreshToken } = response.data;\r\n        localStorage.setItem('token', token);\r\n        localStorage.setItem('refreshToken', newRefreshToken);\r\n\r\n        // Update auth header for original request and queued requests\r\n        apiClient.defaults.headers.common.Authorization = `Bearer ${token}`;\r\n        originalRequest.headers.Authorization = `Bearer ${token}`;\r\n        processQueue(null, token);\r\n\r\n        return apiClient(originalRequest);\r\n      } catch (refreshError) {\r\n        processQueue(refreshError, null);\r\n        // Handle auth failure - redirect to login\r\n        localStorage.removeItem('token');\r\n        localStorage.removeItem('refreshToken');\r\n        window.location = '/login';\r\n        return Promise.reject(refreshError);\r\n      } finally {\r\n        isRefreshing = false;\r\n      }\r\n    }\r\n\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default {\r\n  login(email, password) {\r\n    return apiClient.post('/api/auth/login', { email, password })\r\n      .then(response => {\r\n        // Store both tokens for refresh capability\r\n        const { token, refreshToken } = response.data;\r\n        localStorage.setItem('token', token);\r\n        localStorage.setItem('refreshToken', refreshToken);\r\n        return response;\r\n      });\r\n  },\r\n\r\n  logout() {\r\n    localStorage.removeItem('token');\r\n    localStorage.removeItem('refreshToken');\r\n    return Promise.resolve();\r\n  },\r\n\r\n  getEmployees(page = 0, size = 20) {\r\n    return apiClient.get(`/api/employees?page=${page}&size=${size}`);\r\n  },\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}